*-----------------------------------------------------------------------------------------------------------
* Program:       SNOBOL4 Beautifier
* Author:        Lon Cherryholmes
* First Created: 2002/12/10
* Last Modified: 2005/01/16
* Version:       0.25
*
START
-INCLUDE 'global.inc'
-INCLUDE 'is.inc'
-INCLUDE 'FENCE.inc'
-INCLUDE 'io.inc'
-INCLUDE 'case.inc'
-INCLUDE 'assign.inc'
-INCLUDE 'match.inc'
-INCLUDE 'counter.inc'
-INCLUDE 'stack.inc'
-INCLUDE 'tree.inc'
-INCLUDE 'ShiftReduce.inc'
-INCLUDE 'TDump.inc'
-INCLUDE 'Gen.inc'
-INCLUDE 'Qize.inc'
-INCLUDE 'ReadWrite.inc'
-INCLUDE 'XDump.inc'
-INCLUDE 'semantic.inc'
-INCLUDE 'omega.inc'
-INCLUDE 'trace.inc'

                  &FULLSCAN      =  1
                  &MAXLNGTH      =  524288
*
*                 Four tab-stops defined for the pretty-print routine.
*                 ppStop[1] - subject
*                 ppStop[2] - pattern or =
*                 ppStop[3] - object of assignment
*                 ppStop[4] - goto field
*                 ppSmBump - the amount of extra space when within multi-line nesting
*                 ppLgBump - the amount of extra space when no goto field is present
*
                  ppStop         =  ARRAY('1:4')
                  ppStop[1]      =  18 ;*   11
                  ppStop[2]      =  33 ;*   28
                  ppStop[3]      =  36 ;*   31
                  ppStop[4]      =  81 ;*   66
                  ppSmBump       =  6
                  ppLgBump       =  21
*---------------- -------------- -- ----------------------------------------------- ------------------------
*                 Parser patterns:
*
                  snoInteger     =  SPAN(digits)
                  snoDQ          =  '"' BREAK('"' nl) '"'
                  snoSQ          =  "'" BREAK("'" nl) "'"
                  snoString      =  *snoSQ | *snoDQ
                  snoReal        =  (  SPAN(digits)
+                                      ('.' FENCE(SPAN(digits) | epsilon) | epsilon)
+                                      ('E' | 'e')
+                                      ('+' | '-' | epsilon)
+                                      SPAN(digits)
+                                   |  SPAN(digits) '.' FENCE(SPAN(digits) | epsilon)
+                                   )
                  snoId          =  ANY(&UCASE &LCASE)
+                                   FENCE(SPAN('.' digits &UCASE '_' &LCASE) | epsilon)
                  snoFunction    =  SPAN('.' digits &UCASE '_' &LCASE)
+                                $  tx $ *match(snoFunctions, snoTxInList)
                  snoBuiltinVar  =  SPAN('.' digits &UCASE '_' &LCASE)
+                                $  tx $ *match(snoBuiltinVars, snoTxInList)
                  snoSpecialNm   =  SPAN('.' digits &UCASE '_' &LCASE)
+                                $  tx $ *match(snoSpecialNms, snoTxInList)
                  snoProtKwd     =  '&' SPAN(&UCASE &LCASE) $ tx $ *match(snoProtKwds, snoTxInList)
                  snoUnprotKwd   =  '&' SPAN(&UCASE &LCASE) $ tx $ *match(snoUnprotKwds, snoTxInList)

                  snoGray        =  *snoWhite | epsilon
                  snoWhite       =  (  SPAN(' ' tab)
+                                      FENCE(nl ('+' | '.') FENCE(SPAN(' ' tab) | epsilon) | epsilon)
+                                   |  nl ('+' | '.') FENCE(SPAN(' ' tab) | epsilon)
+                                   )

                  snoTxInList    =  (POS(0) | ' ') *upr(tx) (' ' | RPOS(0))
                  snoSpecialNms  =  'ABORT CONTINUE END FRETURN NRETURN RETURN SCONTINUE START'
                  snoBuiltinVars =  'ABORT ARB BAL FAIL FENCE INPUT OUTPUT REM TERMINAL'
                  snoProtKwds    =  'ABORT ALPHABET ARB BAL FAIL FENCE FILE FNCLEVEL '
+                                   'LASTFILE LASTLINE LASTNO LCASE LINE REM RTNTYPE '
+                                   'STCOUNT STNO SUCCEED UCASE'
                  snoUnprotKwds  =  'ABEND ANCHOR CASE CODE COMPARE DUMP ERRLIMIT '
+                                   'ERRTEXT ERRTYPE FTRACE INPUT MAXLNGTH OUTPUT '
+                                   'PROFILE STLIMIT TRACE TRIM FULLSCAN'
                  snoFunctions   =  'ANY APPLY ARBNO ARG ARRAY ATAN BACKSPACE BREAK BREAKX '
+                                   'CHAR CHOP CLEAR CODE COLLECT CONVERT COPY COS DATA '
+                                   'DATATYPE DATE DEFINE DETACH DIFFER DUMP DUPL EJECT '
+                                   'ENDFILE EQ EVAL EXIT EXP FENCE FIELD GE GT HOST '
+                                   'IDENT INPUT INTEGER ITEM LE LEN LEQ LGE LGT LLE '
+                                   'LLT LN LNE LOAD LOCAL LPAD LT NE NOTANY OPSYN OUTPUT '
+                                   'POS PROTOTYPE REMDR REPLACE REVERSE REWIND RPAD RPOS '
+                                   'RSORT RTAB SET SETEXIT SIN SIZE SORT SPAN SQRT STOPTR '
+                                   'SUBSTR TAB TABLE TAN TIME TRACE TRIM UNLOAD'

                  $'='           =  *snoWhite '=' *snoWhite
                  $'?'           =  *snoWhite '?' *snoWhite
                  $'|'           =  *snoWhite '|' *snoWhite
                  $'+'           =  *snoWhite '+' *snoWhite
                  $'-'           =  *snoWhite '-' *snoWhite
                  $'/'           =  *snoWhite '/' *snoWhite
                  $'*'           =  *snoWhite '*' *snoWhite
                  $'^'           =  *snoWhite '^' *snoWhite
                  $'!'           =  *snoWhite '!' *snoWhite
                  $'**'          =  *snoWhite '**' *snoWhite
                  $'$'           =  *snoWhite '$' *snoWhite
                  $'.'           =  *snoWhite '.' *snoWhite
                  $'&'           =  *snoWhite '&' *snoWhite
                  $'@'           =  *snoWhite '@' *snoWhite
                  $'#'           =  *snoWhite '#' *snoWhite
                  $'%'           =  *snoWhite '%' *snoWhite
                  $'~'           =  *snoWhite '~' *snoWhite
                  $','           =  *snoGray ',' *snoGray
                  $'('           =  '(' *snoGray
                  $'['           =  '[' *snoGray
                  $'<'           =  '<' *snoGray
                  $')'           =  *snoGray ')'
                  $']'           =  *snoGray ']'
                  $'>'           =  *snoGray '>'

                  snoExprList    =  nPush()
+                                   *snoXList
+                                   ("'snoExprList'" & '*(GT(nTop(), 1) nTop())')
+                                   nPop()
                  snoXList       =  nInc() (*snoExpr | epsilon ~ '') FENCE($',' *snoXList | epsilon)
                  snoExpr        =  *snoExpr0
                  snoExpr0       =  *snoExpr1 FENCE($'=' *snoExpr0 ("'='" & 2) | epsilon)
                  snoExpr1       =  *snoExpr2 FENCE($'?' *snoExpr1 ("'?'" & 2) | epsilon)
                  snoExpr2       =  *snoExpr3 FENCE($'&' *snoExpr2 ("'&'" & 2) | epsilon)
                  snoExpr3       =  nPush() *snoX3 ("'|'" & '*(GT(nTop(), 1) nTop())') nPop()
                  snoX3          =  nInc() *snoExpr4 FENCE($'|' *snoX3 | epsilon)
                  snoExpr4       =  nPush() *snoX4 ("'..'" & '*(GT(nTop(), 1) nTop())') nPop()
                  snoX4          =  nInc() *snoExpr5 FENCE(*snoWhite *snoX4 | epsilon)
                  snoExpr5       =  *snoExpr6 FENCE($'@' *snoExpr5 ("'@'" & 2) | epsilon)
                  snoExpr6       =  *snoExpr7
+                                   FENCE(
+                                      $'+' *snoExpr6 ("'+'" & 2) | $'-' *snoExpr6 ("'-'" & 2) | epsilon
+                                   )
                  snoExpr7       =  *snoExpr8 FENCE($'#' *snoExpr7 ("'#'" & 2) | epsilon)
                  snoExpr8       =  *snoExpr9 FENCE($'/' *snoExpr8 ("'/'" & 2) | epsilon)
                  snoExpr9       =  *snoExpr10 FENCE($'*' *snoExpr9 ("'*'" & 2) | epsilon)
                  snoExpr10      =  *snoExpr11 FENCE($'%' *snoExpr10 ("'%'" & 2) | epsilon)
                  snoExpr11      =  *snoExpr12
+                                   FENCE(($'^' | $'!' | $'**') *snoExpr11 ("'^'" & 2) | epsilon)
                  snoExpr12      =  *snoExpr13
+                                   FENCE(
+                                      $'$' *snoExpr12 ("'$'" & 2)
+                                   |  $'.' *snoExpr12 ("'.'" & 2)
+                                   |  epsilon
+                                   )
                  snoExpr13      =  *snoExpr14 FENCE($'~' *snoExpr13 ("'~'" & 2) | epsilon)
                  snoExpr14      =  '@' *snoExpr14 ("'@'" & 1)
+                                |  '~' *snoExpr14 ("'~'" & 1)
+                                |  '?' *snoExpr14 ("'?'" & 1)
+                                |  *snoProtKwd ~ 'snoProtKwd'
+                                |  *snoUnprotKwd ~ 'snoUnprotKwd'
+                                |  '&' *snoExpr14 ("'&'" & 1)
+                                |  '+' *snoExpr14 ("'+'" & 1)
+                                |  '-' *snoExpr14 ("'-'" & 1)
+                                |  '*' *snoExpr14 ("'*'" & 1)
+                                |  '$' *snoExpr14 ("'$'" & 1)
+                                |  '.' *snoExpr14 ("'.'" & 1)
+                                |  '!' *snoExpr14 ("'!'" & 1)
+                                |  '%' *snoExpr14 ("'%'" & 1)
+                                |  '/' *snoExpr14 ("'/'" & 1)
+                                |  '#' *snoExpr14 ("'#'" & 1)
+                                |  '=' *snoExpr14 ("'='" & 1)
+                                |  '|' *snoExpr14 ("'|'" & 1)
+                                |  *snoExpr15
                  snoExpr15      =  *snoExpr17
+                                   FENCE(nPush() *snoExpr16 ("'[]'" & 'nTop() + 1') nPop() | epsilon)
                  snoExpr16      =  nInc()
+                                   ($'[' *snoExprList $']' | $'<' *snoExprList $'>')
+                                   FENCE(*snoExpr16 | epsilon)
                  snoExpr17      =  FENCE(
+                                      nPush()
+                                      $'('
+                                      *snoExpr
+                                      (  $',' *snoXList ("','" & 'nTop() + 1')
+                                      |  epsilon ("'()'" & 1)
+                                      )
+                                      $')'
+                                      nPop()
+                                   |  *snoFunction ~ 'snoFunction' $'(' *snoExprList $')' ("'snoCall'" & 2)
+                                   |  *snoId ~ 'snoId' $'(' *snoExprList $')' ("'snoCall'" & 2)
+                                   |  *snoBuiltinVar ~ 'snoBuiltinVar'
+                                   |  *snoSpecialNm ~ 'snoSpecialNm'
+                                   |  *snoId ~ 'snoId'
+                                   |  *snoString ~ 'snoString'
+                                   |  *snoReal ~ 'snoReal'
+                                   |  *snoInteger ~ 'snoInteger'
+                                   )

                  snoSGoto       =  ('S' | 's') . *assign(.SorF, *'S')
                  snoFGoto       =  ('F' | 'f') . *assign(.SorF, *'F')
                  snoSorF        =  *snoSGoto | *snoFGoto
                  snoTarget      =  $'(' . *assign(.snoBrackets, *'()') *snoExpr $')'
+                                |  $'<' . *assign(.snoBrackets, *'<>') *snoExpr $'>'
                  snoGoto        =  *snoGray ':'
+                                   *snoGray
+                                   FENCE(
+                                      *snoTarget ("*(':' snoBrackets)" & 1) epsilon ~ ''
+                                   |  *snoSorF *snoTarget ("*(':' SorF snoBrackets)" & 1)
+                                      FENCE(*snoGray *snoSorF *snoTarget ("*(':' SorF snoBrackets)" & 1) | epsilon ~ '')
+                                   )
                  snoControl     =  '-' BREAK(nl ';')
                  snoComment     =  '*' BREAK(nl)
                  snoLabel       =  BREAK(' ' tab nl ';') ~ 'snoLabel'
                  snoStmt        =  *snoLabel
+                                   (  *snoWhite
+                                      *snoExpr14
+                                      FENCE(
+                                         epsilon ~ ''
+                                         *snoWhite
+                                         ('=' ~ '=' *snoWhite *snoExpr | '=' ~ '=' epsilon ~ '')
+                                      |  ($'?' | *snoWhite)
+                                         *snoExpr1
+                                         FENCE(
+                                            *snoWhite
+                                            ('=' ~ '=' *snoWhite *snoExpr | '=' ~ '=' epsilon ~ '')
+                                         |  epsilon ~ '' epsilon ~ ''
+                                         )
+                                      |  epsilon ~ '' epsilon ~ '' epsilon ~ ''
+                                      )
+                                   |  epsilon ~ '' epsilon ~ '' epsilon ~ '' epsilon ~ ''
+                                   )
+                                   FENCE(*snoGoto | epsilon ~ '' epsilon ~ '')
+                                   *snoGray

                  snoCommands    =  *snoCommand FENCE(*snoCommands | epsilon)
                  snoCommand     =  nInc()
+                                   FENCE(
+                                      *snoComment ~ 'comment' ("'snoComment'" & 1) nl
+                                   |  *snoControl ~ 'control' ("'snoControl'" & 1) (nl | ';')
+                                   |  *snoStmt ("'snoStmt'" & 7) (nl | ';')
+                                   )

                  snoParse       =  nPush()
+                                   ARBNO(*snoCommand)
+                                   ("'snoParse'" & 'nTop()')
+                                   nPop()

                  snoCompiland   =  nPush()
+                                   ARBNO(*snoCommand)
+                                   ("'snoParse'" & 'nTop()')
+                                   (icase('END') (' ' BREAK(nl) nl | nl) ARBNO(BREAK(nl) nl) | epsilon)
+                                   nPop()

*================ ============== == =============================================== ========================
*                 Pretty-print routine.
*                 null = pp(x=tree)
*                 Recursive routine given a tree, to output SNOBOL4 code.
*
                  DEFINE('pp(x)c,i,n,s,t,v')                                        :(ppEnd)
pp                DIFFER(x)                                                         :F(RETURN)
                  t              =  t(x)
                  v              =  v(x)
                  n              =  n(x)
                  c              =  c(x)
                  OUTPUT         =  GT(doDebug, 0) 'pp(' t ')' ', sz = ' level '+' SIZE(v) ', v = ' v
                  DIFFER(t)                                                         :S($('pp_' t))F(RETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_snoParse       ppWidth        =  ppStop[4]                                       :(pp_0)
pp_0              i              =  0
pp_1              i              =  LT(i, n) i + 1                                  :F(RETURN)
                  pp(c[i])                                                          :(pp_1)
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_snoBuiltinVar  Gen(ss(x))                                                        :S(RETURN)F(error)
pp_snoFunction    Gen(ss(x))                                                        :S(RETURN)F(error)
pp_snoId          Gen(ss(x))                                                        :S(RETURN)F(error)
pp_snoInteger     Gen(ss(x))                                                        :S(RETURN)F(error)
pp_snoLabel       Gen(ss(x))                                                        :S(RETURN)F(error)
pp_snoProtKwd     Gen(ss(x))                                                        :S(RETURN)F(error)
pp_snoReal        Gen(ss(x))                                                        :S(RETURN)F(error)
pp_snoSpecialNm   Gen(ss(x))                                                        :S(RETURN)F(error)
pp_snoString      Gen(ss(x))                                                        :S(RETURN)F(error)
pp_snoUnprotKwd   Gen(ss(x))                                                        :S(RETURN)F(error)
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_:()            Gen(ss(x))                                                        :S(RETURN)F(error)
pp_:<>            Gen(ss(x))                                                        :S(RETURN)F(error)
pp_:S()           Gen(ss(x))                                                        :S(RETURN)F(error)
pp_:S<>           Gen(ss(x))                                                        :S(RETURN)F(error)
pp_:F()           Gen(ss(x))                                                        :S(RETURN)F(error)
pp_:F<>           Gen(ss(x))                                                        :S(RETURN)F(error)
*---------------- -------------- -- ----------------------------------------------- ------------------------
ppUnOp            Gen(ss(x, ppWidth - GetLevel()))                                  :S(RETURN)
                  Gen(t)
                  pp(c[1])                                                          :(RETURN)
ppBinOp           Gen(ss(x, ppWidth - GetLevel()))                                  :S(RETURN)
                  pp(c[1])
                  Gen(nl)
                  DecLevel()
                  Gen(t)
                  IncLevel()
                  GenTab()
                  pp(c[2])                                                          :(RETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_!              EQ(n, 1)                                                          :S(ppUnOp)
pp_#              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_$              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_%              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_&              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_*              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_+              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_-              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_.              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_/              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_=              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_?              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_@              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_^              EQ(n, 2)                                                          :S(ppBinOp)F(error)
pp_~              EQ(n, 1)                                                          :S(ppUnOp)
                  EQ(n, 2)                                                          :S(ppBinOp)F(error)
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_snoComment     SetLevel(0)
                  GenSetCont()
                  Gen(v(c[1]) nl)                                                   :(RETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_snoControl     SetLevel(0)
                  GenSetCont()
                  Gen(v(c[1]) nl)                                                   :(RETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_snoStmt        SetLevel(0)
                  GenSetCont('+')
                  ppWidth        =  ppStop[4]
                  ppLbl          =  ss(c[1])
                  ppSubj         =  c[2]
                  ppPatrn        =  c[3]
                  ppAsgn         =  v(c[4])
                  ppRepl         =  c[5]
                  ppGo1          =  c[6]
                  ppGo2          =  c[7]
                  Gen(ppLbl)
                  DIFFER(t(ppSubj))                                                 :F(pp_snoStmt7)
                  Gen(' ')
                  GenTab(ppStop[1])
                  SetLevel(ppStop[1])
                  ppWidth        =  IDENT(t(ppPatrn)) IDENT(ppAsgn) IDENT(t(ppGo1)) ppStop[4] + ppLgBump
                  pp(ppSubj)
                  DIFFER(t(ppPatrn))                                                :F(pp_snoStmt5)
                  Gen(' ')
                  GenTab(ppStop[2])
                  SetLevel(ppStop[2])
                  ppWidth        =  IDENT(ppAsgn) IDENT(t(ppGo1)) ppStop[4] + ppLgBump
                  pp(ppPatrn)
                  DIFFER(ppAsgn)                                                    :F(pp_snoStmt7)
                  Gen(' =')
                  DIFFER(t(ppRepl))                                                 :F(pp_snoStmt7)
                  Gen(' ')
                  pp(ppRepl)                                                        :(pp_snoStmt7)
pp_snoStmt5       DIFFER(ppAsgn)                                                    :F(pp_snoStmt7)
                  Gen(' ')
                  GenTab(ppStop[2])
                  SetLevel(ppStop[2])
                  Gen('=')
                  DIFFER(t(ppRepl))                                                 :F(pp_snoStmt7)
                  Gen(' ')
                  GenTab(ppStop[3])
                  SetLevel(ppStop[3])
                  ppWidth        =  IDENT(t(ppGo1)) ppStop[4] + ppLgBump
                  pp(ppRepl)                                                        :(pp_snoStmt7)
pp_snoStmt7       DIFFER(t(ppGo1))                                                  :F(pp_snoStmt9)
                  ppWidth        =  256
                  Gen(' ')
                  GenTab(ppStop[4])
                  SetLevel(ppStop[4])
                  Gen(':')
                  pp(ppGo1)
                  DIFFER(t(ppGo2))                                                  :F(pp_snoStmt9)
                  pp(ppGo2)                                                         :(pp_snoStmt9)
pp_snoStmt9       Gen(nl)                                                           :(RETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_snoExprList    Gen(ss(x, ppWidth - GetLevel()))                                  :S(RETURN)
                  pp(c[1])
                  i              =  1
pp_snoExprList0   i              =  LT(i, n) i + 1                                  :F(RETURN)
                  Gen(nl)
                  DecLevel()
                  Gen(',')
                  IncLevel()
                  GenTab()
                  pp(c[i])                                                          :(pp_snoExprList0)
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_,              Gen(ss(x, ppWidth - GetLevel()))                                  :S(RETURN)
                  Gen('(')
                  IncLevel()
                  GenTab()
                  pp(c[1])
                  i              =  1
pp_,0             i              =  LT(i, n) i + 1                                  :F($'pp_,1')
                  Gen(nl)
                  DecLevel()
                  Gen(',')
                  IncLevel()
                  GenTab()
                  pp(c[i])                                                          :($'pp_,0')
pp_,1             Gen(nl)
                  DecLevel()
                  Gen(')')                                                          :(RETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_|              EQ(n, 1)                                                          :S(ppUnOp)
                  Gen(ss(x, ppWidth - GetLevel()))                                  :S(RETURN)
                  pp(c[1])
                  i              =  1
pp_|0             i              =  LT(i, n) i + 1                                  :F(RETURN)
                  Gen(nl)
                  DecLevel()
                  Gen('|')
                  IncLevel()
                  GenTab()
                  pp(c[i])                                                          :($'pp_|0')
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_..             Gen(ss(x, ppWidth - GetLevel()))                                  :S(RETURN)
                  i              =  0
pp_..0            i              =  LT(i, n) i + 1                                  :F(RETURN)
                  pp(c[i])
                  (LT(i, n) Gen(nl))                                                :($'pp_..0')
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_[]             Gen(ss(x, ppWidth - GetLevel()))                                  :S(RETURN)
                  pp(c[1])
                  i              =  1
pp_[]0            i              =  LT(i, n) i + 1                                  :F(RETURN)
                  Gen('[')
                  IncLevel()
                  GenTab()
                  pp(c[i])
                  Gen(nl)
                  DecLevel()
                  Gen(']')
                  (LT(i, n) Gen(nl))                                                :($'pp_[]0')
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_()             Gen(ss(x, ppWidth - GetLevel()))                                  :S(RETURN)
                  Gen('(')
                  IncLevel()
                  GenTab()
                  pp(c[1])
                  Gen(nl)
                  DecLevel()
                  Gen(')')                                                          :(RETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
pp_snoCall        Gen(ss(x, ppWidth - GetLevel()))                                  :S(RETURN)
                  pp(c[1])
                  Gen('(' nl)
                  IncLevel()
                  GenTab()
                  pp(c[2])
                  Gen(nl)
                  DecLevel()
                  Gen(')')                                                          :(RETURN)
ppEnd
*================ ============== == =============================================== ========================
*                 Stringize Subject
*                 string = ss(x=tree, len=integer)
*                 Recursive function given a tree, to return SNOBOL4 code as a string.
*
                  DEFINE('ss(x,len)c,c1,c2,i,n,s,t,v')                              :(ssEnd)
ss                DIFFER(x)                                                         :F(RETURN)
                  len            =  IDENT(len) 1024
                  GT(len, 0)                                                        :F(FRETURN)
                  t              =  t(x)
                  v              =  v(x)
                  n              =  n(x)
                  c              =  c(x)
                  OUTPUT         =  GT(doDebug, 0) 'ss(' t ')' ', sz = ' level '+' SIZE(v) ', v = ' v
                  DIFFER(t)                                                         :S($('ss_' t))F(RETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
ss_snoBuiltinVar  ss             =  upr(v)                                          :(ss_atomic)
ss_snoFunction    ss             =  upr(v)                                          :(ss_atomic)
ss_snoId          ss             =  v                                               :(ss_atomic)
ss_snoInteger     ss             =  v                                               :(ss_atomic)
ss_snoLabel       v              POS(0) *snoSpecialNm RPOS(0)                       :S(ss_snoLabel0)F(ss_snoLabel1)
ss_snoLabel0      ss             =  upr(v)                                          :(ss_atomic)
ss_snoLabel1      ss             =  v                                               :(ss_atomic)
ss_snoProtKwd     ss             =  upr(v)                                          :(ss_atomic)
ss_snoReal        ss             =  v                                               :(ss_atomic)
ss_snoSpecialNm   ss             =  upr(v)                                          :(ss_atomic)
ss_snoString      ss             =  v                                               :(ss_atomic)
ss_snoUnprotKwd   ss             =  upr(v)                                          :(ss_atomic)
ss_atomic         LE(SIZE(ss), len)                                                 :S(RETURN)F(FRETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
ss_:()            ss             =  '(' ss(c[1], len - 2) ')'                       :S(RETURN)F(error)
ss_:<>            ss             =  '<' ss(c[1], len - 2) '>'                       :S(RETURN)F(error)
ss_:S()           ss             =  'S(' ss(c[1], len - 3) ')'                      :S(RETURN)F(error)
ss_:S<>           ss             =  'S<' ss(c[1], len - 3) '>'                      :S(RETURN)F(error)
ss_:F()           ss             =  'F(' ss(c[1], len - 3) ')'                      :S(RETURN)F(error)
ss_:F<>           ss             =  'F<' ss(c[1], len - 3) '>'                      :S(RETURN)F(error)
*---------------- -------------- -- ----------------------------------------------- ------------------------
ssUnOp            ss             =  t ss(c[1], len - SIZE(t))                       :S(RETURN)F(FRETURN)
ssBinOp           ss             =  ss(c[1], len)                                   :F(FRETURN)
                  ss             =  ss ' ' t ' ' ss(c[2], len - SIZE(ss) - SIZE(t) - 2) :S(RETURN)F(FRETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
ss_!              EQ(n, 1)                                                          :S(ssUnOp)
ss_#              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_$              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_%              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_&              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_*              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_+              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_-              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_.              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_/              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_=              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_?              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_@              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_^              EQ(n, 2)                                                          :S(ssBinOp)F(error)
ss_~              EQ(n, 1)                                                          :S(ssUnOp)
                  EQ(n, 2)                                                          :S(ssBinOp)F(error)
*---------------- -------------- -- ----------------------------------------------- ------------------------
ss_snoExprList    ss             =  ss(c[1], len)                                   :F(FRETURN)
                  i              =  1
ss_snoExprList0   i              =  LT(i, n) i + 1                                  :F(RETURN)
                  ss             =  ss ', ' ss(c[i], len - SIZE(ss) - 2)            :S(ss_snoExprList0)F(FRETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
ss_,              ss             =  '(' ss(c[1], len - 4)                           :F(FRETURN)
                  i              =  1
ss_,0             i              =  LT(i, n) i + 1                                  :F($'ss_,1')
                  ss             =  ss ', ' ss(c[i], len - SIZE(ss) - 3)            :S($'ss_,0')F(FRETURN)
ss_,1             ss             =  ss ')'                                          :(RETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
ss_|              EQ(n, 1)                                                          :S(ssUnOp)
                  ss             =  ss(c[1], len)                                   :F(FRETURN)
                  i              =  1
ss_|0             i              =  LT(i, n) i + 1                                  :F(RETURN)
                  ss             =  ss ' | ' ss(c[i], len - SIZE(ss) - 3)           :S($'ss_|0')F(FRETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
ss_..             ss             =  ss(c[1], len)                                   :F(FRETURN)
                  i              =  1
ss_..0            i              =  LT(i, n) i + 1                                  :F(RETURN)
                  ss             =  ss ' ' ss(c[i], len - SIZE(ss) - 1)             :S($'ss_..0')F(FRETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
ss_[]             ss             =  ss(c[1], len)                                   :F(FRETURN)
                  i              =  1
ss_[]0            i              =  LT(i, n) i + 1                                  :F(RETURN)
                  ss             =  ss '[' ss(c[i], len - SIZE(ss) - 2) ']'         :S($'ss_[]0')F(FRETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
ss_()             ss             =  '(' ss(c[1], len - 2) ')'                       :S(RETURN)F(FRETURN)
*---------------- -------------- -- ----------------------------------------------- ------------------------
ss_snoCall        ss             =  ss(c[1]) '(' ss(c[2], len - SIZE(v) - 2) ')'    :S(RETURN)F(FRETURN)
ssEnd
*================ ============== == =============================================== ========================
                  DEFINE('visit(x,fnc)i')                                           :(visitEnd)
visit             APPLY(fnc, x)                                                     :F(RETURN)
                  i              =  0
visit_1           i              =  LT(i, n(x)) i + 1                               :F(RETURN)
                  visit(c(x)[i], fnc)                                               :(visit_1)
visitEnd
*---------------- -------------- -- ----------------------------------------------- ------------------------
                  DEFINE('findRefs(x)n,v')
                  snoRefs        =                                                  :(findRefsEnd)
findRefs          DIFFER(x)                                                         :F(RETURN)
                  IDENT(t(x), 'snoCall')                                            :F(findRefs_1)
                  n              =  1
findRefs_0        n              =  LT(n, n(x)) n + 1                               :F(FRETURN)
                  visit(c(x)[n], .findRefs)                                         :(findRefs_0)
findRefs_1        (IDENT(t(x), '&') EQ(n(x), 1))                                    :F(findRefs_2)
                  v              =  ss(x)                                           :(findRefs_9)
findRefs_2        IDENT(t(x), 'snoId')                                              :F(RETURN)
                  v              =  v(x)                                            :(findRefs_9)
findRefs_9        v              POS(0) SPAN('0123456789' &UCASE '_') RPOS(0)       :F(FRETURN)
                  snoRefs        =  DIFFER(snoRefs) snoRefs ' ' v                   :S(FRETURN)
                  snoRefs        =  IDENT(snoRefs) v                                :(FRETURN)
findRefsEnd
*---------------- -------------- -- ----------------------------------------------- ------------------------
                  DEFINE('refs(p)c,n,s,subj')                                       :(refsEnd)
refs              c              =  c(p)
                  n              =  0
refs_0            n              =  LT(n, n(p)) n + 1                               :F(RETURN)
                  IDENT(t(c[n]), 'snoStmt')                                         :F(refs_0)
                  s              =  s + 1
                  IDENT(t(c(c[n])[3]))                                              :F(refs_0)
                  IDENT(t(c(c[n])[4]), '=')                                         :F(refs_0)
                  IDENT(t(c(c[n])[2]), 'snoId')                                     :S(refs_1)
                  IDENT(t(c(c[n])[2]), '$')                                         :S(refs_1)F(refs_0)
refs_1            subj           =  ss(c(c[n])[2])
                  snoRefs        =
                  visit(c(c[n])[5], .findRefs)
                  OUTPUT         =  LPAD(s, 3, 0) ': ' RPAD(subj, 38) ' ' snoRefs   :(refs_0)
refsEnd
*================ ============== == =============================================== ========================
*                 Main program.
*                 Read a SNOBOL4 program.
*                 Parse the SNOBOL4 program.
*                 Generate a more beautiful SNOBOL4 program.
*
                  doDebug        =  0
                  snoSpace       =  SPAN(' ' tab) | epsilon
main00            snoLine        =  INPUT                                           :F(END)
main01            snoSrc         =
                  snoLine        POS(0) ANY('*-')                                   :F(main02)
                  OUTPUT         =  snoLine                                         :(main00)
main02            snoSrc         =  snoSrc snoLine nl
                  snoLine        =  INPUT                                           :F(main05)
                  snoLine        POS(0) ANY('.+')                                   :S(main02)
                  snoSrc         POS(0) *snoParse *snoSpace RPOS(0)                 :F(mainErr1)
                  DIFFER(sno = Pop())                                               :F(mainErr2)
                  pp(sno)                                                           :(main01)
main05            snoSrc         POS(0) *snoParse *snoSpace RPOS(0)                 :F(mainErr1)
                  DIFFER(sno = Pop())                                               :F(mainErr2)
                  pp(sno)                                                           :(END)
mainErr1          OUTPUT         =  'Parse Error'
                  OUTPUT         =  snoSrc                                          :(END)
mainErr2          OUTPUT         =  'Internal Error'
                  OUTPUT         =  snoSrc                                          :(END)
*-INCLUDE 'debug.sno'
END
